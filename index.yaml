apiVersion: v1
entries:
  ripe-atlas-probe:
  - apiVersion: v2
    appVersion: 1.16.0
    created: "2024-12-30T17:59:06.060653983Z"
    description: '# RIPE-NCC atlas probe helm chart  This helm chart will install
      a RIPE NCC [software atlas probe](https://www.ripe.net/analyse/internet-measurements/ripe-atlas/host-a-probe/#software-probes).
      Packages [here](https://atlas.ripe.net/docs/howtos/software-probes.html)  This
      chart will also create the neccessary ssh keys for the probe usage and then
      to upload these onto the RIPE Atlas portal. After running this chart, copy the
      public key generated by the key generation job and copy it over on the Atlas
      probe creation screen at https://atlas.ripe.net/apply/swprobe/.  If you already
      have a software probe, you can reuse it√ü and just add the generated public key
      in the "Update SSH key" section of the probe.  ## How to install the chart  ###
      Generic install  The default CSI will be used to create the atlas probe status
      volume.  ``` helm install ripe-atlas-probe ripe-atlas-probe \   --namespace
      ripe-atlas-probe --create-namespace ```  ### Specifying the Storage CSI  ```
      helm upgrade -i ripe-atlas-probe ripe-atlas-probe \   --namespace ripe-atlas-probe
      --create-namespace \   --set persistentVolumeClaim.storageClass="nfs-csi"  ```  ###
      Skip creating the ssh key pair  If you already have some ssh keypair files tha
      tyou want to reuse, then you can run the following first to install the chart:  ```
      helm install ripe-atlas-probe ripe-atlas-probe \   --namespace ripe-atlas-probe
      --create-namespace \   --set persistentVolumeClaim.storageClass="nfs-csi" \   --set
      job.sshKeyGen.enabled=false ```  Then you can import the sshe keypair assuming
      these are named `probe_key` and `probe_key.pub`:  ``` kubectl create secret
      generic ssh-keypair \   --from-file=probe_key=/tmp/probe_key \   --from-file=probe_key.pub=/tmp/probe_key.pub
      \   -n ripe-atlas-probe --dry-run=client -o yaml | kubectl apply -f - ```  ##
      Uploading the secret the Atlas portal  The generated public ssh key is available
      at the following secret:  ``` kubectl get secret --namespace ripe-atlas-probe
      ripe-atlas-secret -o jsonpath="{.data.probe_key\.pub}" | base64 -d ``` '
    digest: cebd96bdcceb5f578760b44c4c7672ed4ebc2f5047f961e321ccf7512d529f81
    name: ripe-atlas-probe
    type: application
    urls:
    - https://github.com/besmirzanaj/charts/releases/download/ripe-atlas-probe-0.1.5/ripe-atlas-probe-0.1.5.tgz
    version: 0.1.5
  - apiVersion: v2
    appVersion: 1.16.0
    created: "2024-12-30T17:42:39.02005485Z"
    description: '# RIPE-NCC atlas probe helm chart  This helm chart will install
      a RIPE NCC [software atlas probe](https://www.ripe.net/analyse/internet-measurements/ripe-atlas/host-a-probe/#software-probes).
      Packages [here](https://atlas.ripe.net/docs/howtos/software-probes.html)  This
      chart will also create the neccessary ssh keys for the probe usage and then
      to upload these onto the RIPE Atlas portal. After running this chart, copy the
      public key generated by the key generation job and copy it over on the Atlas
      probe creation screen at https://atlas.ripe.net/apply/swprobe/.  If you already
      have a software probe, you can reuse it and just add the generated public key
      in the "Update SSH key" section of the probe.  ## How to install the chart  ###
      Generic install  The default CSI will be used to create the atlas probe status
      volume.  ``` helm install ripe-atlas-probe ripe-atlas-probe \   --namespace
      ripe-atlas-probe --create-namespace ```  ### Specifying the Storage CSI  ```
      helm upgrade -i ripe-atlas-probe ripe-atlas-probe \   --namespace ripe-atlas-probe
      --create-namespace \   --set persistentVolumeClaim.storageClass="nfs-csi"  ```  ###
      Skip creating the ssh key pair  If you already have some ssh keypair files tha
      tyou want to reuse, then you can run the following first to install the chart:  ```
      helm install ripe-atlas-probe ripe-atlas-probe \   --namespace ripe-atlas-probe
      --create-namespace \   --set persistentVolumeClaim.storageClass="nfs-csi" \   --set
      job.sshKeyGen.enabled=false ```  Then you can import the sshe keypair assuming
      these are named `probe_key` and `probe_key.pub`:  ``` kubectl create secret
      generic ssh-keypair \   --from-file=probe_key=/tmp/probe_key \   --from-file=probe_key.pub=/tmp/probe_key.pub
      \   -n ripe-atlas-probe --dry-run=client -o yaml | kubectl apply -f - ```  ##
      Uploading the secret the Atlas portal  The generated public ssh key is available
      at the following secret:  ``` kubectl get secret --namespace ripe-atlas-probe
      ripe-atlas-secret -o jsonpath="{.data.probe_key\.pub}" | base64 -d ``` '
    digest: d916360f7eb2613080008deebab1f3b8ed248096219073b6f81da494b0b1954c
    name: ripe-atlas-probe
    type: application
    urls:
    - https://github.com/besmirzanaj/charts/releases/download/ripe-atlas-probe-0.1.4/ripe-atlas-probe-0.1.4.tgz
    version: 0.1.4
  - apiVersion: v2
    appVersion: 1.16.0
    created: "2024-12-11T23:41:12.750366268Z"
    description: '# RIPE-NCC atlas probe helm chart  This helm chart will install
      a RIPE NCC [software atlas probe](https://www.ripe.net/analyse/internet-measurements/ripe-atlas/host-a-probe/#software-probes).
      Packages [here](https://atlas.ripe.net/docs/howtos/software-probes.html)  This
      chart will also create the neccessary ssh keys for the probe usage and then
      to upload these onto the RIPE Atlas portal. After running this chart, copy the
      public key generated by the key generation job and copy it over on the Atlas
      probe creation screen at https://atlas.ripe.net/apply/swprobe/.  If you already
      have a software probe, you can reuse it and just add the generated public key
      in the "Update SSH key" section of the probe.  ## How to install the chart  ###
      Generic install  The default CSI will be used to create the atlas probe status
      volume.  ``` helm install ripe-atlas-probe ripe-atlas-probe \   --namespace
      ripe-atlas-probe --create-namespace ```  ### Specifying the Storage CSI  ```
      helm upgrade -i ripe-atlas-probe ripe-atlas-probe \   --namespace ripe-atlas-probe
      --create-namespace \   --set persistentVolumeClaim.storageClass="nfs-csi"  ```  ###
      Skip creating the ssh key pair  If you already have some ssh keypair files tha
      tyou want to reuse, then you can run the following first to install the chart:  ```
      helm install ripe-atlas-probe ripe-atlas-probe \   --namespace ripe-atlas-probe
      --create-namespace \   --set persistentVolumeClaim.storageClass="nfs-csi" \   --set
      job.sshKeyGen.enabled=false ```  Then you can import the sshe keypair assuming
      these are named `probe_key` and `probe_key.pub`:  ``` kubectl create secret
      generic ssh-keypair \   --from-file=probe_key=/tmp/probe_key \   --from-file=probe_key.pub=/tmp/probe_key.pub
      \   -n ripe-atlas-probe --dry-run=client -o yaml | kubectl apply -f - ```  ##
      Uploading the secret the Atlas portal  The generated public ssh key is available
      at the following secret:  ``` kubectl get secret --namespace ripe-atlas-probe
      ripe-atlas-secret -o jsonpath="{.data.probe_key\.pub}" | base64 -d ``` '
    digest: 07afd8bbba4f1baa4ee57222358dc1c1d5267e08b2d9f25993e20630576677d5
    name: ripe-atlas-probe
    type: application
    urls:
    - https://github.com/besmirzanaj/charts/releases/download/ripe-atlas-probe-0.1.3/ripe-atlas-probe-0.1.3.tgz
    version: 0.1.3
  - apiVersion: v2
    appVersion: 1.16.0
    created: "2024-12-10T05:27:23.534074184Z"
    description: A Helm chart for running a ripe atlas probe in Kubernetes
    digest: 8f00faec50e39c6b2c5cf182ebb8b5661db48fe7d9fd73877f9299c363149e43
    name: ripe-atlas-probe
    type: application
    urls:
    - https://github.com/besmirzanaj/charts/releases/download/ripe-atlas-probe-0.1.2/ripe-atlas-probe-0.1.2.tgz
    version: 0.1.2
  - apiVersion: v2
    appVersion: 1.16.0
    created: "2024-12-10T04:46:36.849084462Z"
    description: A Helm chart for running a ripe atlas probe in Kubernetes
    digest: 4f0c8b496d2ca931e2386dd2c1144f21ee55ef63fa5e5f6362bd3a31e7c015af
    name: ripe-atlas-probe
    type: application
    urls:
    - https://github.com/besmirzanaj/charts/releases/download/ripe-atlas-probe-0.1.1/ripe-atlas-probe-0.1.1.tgz
    version: 0.1.1
  - apiVersion: v2
    appVersion: 1.16.0
    created: "2024-10-05T17:24:13.8982983-04:00"
    description: A Helm chart for running a ripe atlas probe in Kubernetes
    digest: e6d0f41523b1655fe1ea39d156671f249c5cc111d7252352ab40641ca7e669e7
    name: ripe-atlas-probe
    type: application
    urls:
    - https://besmirzanaj.github.io/charts/ripe-atlas-probe-0.1.0.tgz
    version: 0.1.0
  validate-email:
  - apiVersion: v2
    appVersion: 0.2.7
    created: "2024-12-17T15:23:19.135831354Z"
    description: '# validate-email  Check email validity.  ## Introduction  This code
      will validate an email address if it is active. When you run it, make sure your
      host is allowed outbound access to port 25. Some VPS providers will ont allow
      that.  Can be run with [webook](https://github.com/adnanh/webhook) in BASH or
      with [Flask](https://flask.palletsprojects.com/en/stable/) in Python.   ## Running
      the program in BASH The Bash version will only allow bearer token authentication
      with a username/password combination.  **Locally in BASH**  This is not meant
      to be run from the console. Use the docker version below. If absolutely you
      need to run it, then, first update the `VALIDATE_API_USER` and `VALIDATE_API_PASSWORD`
      variables in the `.env` file or declare them as environment variables. Then
      run the app. An example below with declaring the env variables on the fly  ```bash
      $  VALIDATE_API_USER=validate_user VALIDATE_API_PASSWORD=validate_password ./src/bash_entrypoint.sh
      VALIDATE_API_PASSWORD=validate_password VALIDATE_API_USER=validate_user BEARER_TOKEN=dmFsaWRhdGVfdXNlcjp2YWxpZGF0ZV9wYXNzd29yZAo=
      [webhook] 2024/12/06 18:01:06 version 2.8.0 starting [webhook] 2024/12/06 18:01:06
      setting up os signal watcher [webhook] 2024/12/06 18:01:06 attempting to load
      hooks from ./src/valid_email.yml [webhook] 2024/12/06 18:01:06 os signal watcher
      ready [webhook] 2024/12/06 18:01:06 found 1 hook(s) in file [webhook] 2024/12/06
      18:01:06   loaded: validate_email [webhook] 2024/12/06 18:01:06 serving hooks
      on http://0.0.0.0:9001/hooks/{id} ```  Then issue the call with curl:  ```bash
      VALIDATE_HOSTNAME="http://vps3.cloudalbania.com" # replace with the hostname
      you are running this, could be also 127.0.0.1 VALIDATE_URL="$VALIDATE_HOSTNAME:9001/hooks/validate_email"
      VALIDATE_API_USER="validate_user" # update with your user here VALIDATE_API_PASSWORD="validate_password"
      # update with your password here VALIDATE_AUTH_HEADER="Authorization: Bearer
      $(echo $VALIDATE_API_USER:$VALIDATE_API_PASSWORD | base64)"  $ curl -s --url
      "$VALIDATE_URL" \   -X POST -d ''{"email":"besmirtv@gmail.com"}'' \   -H "Content-type:
      Application/json" \   -H "$VALIDATE_AUTH_HEADER" | jq  {   "email": "besmirtv@gmail.com",   "status":
      "true" } ```  **Bash in docker version**  Start it with the following. Remember
      that `VALIDATE_API_USER` and `VALIDATE_API_PASSWORD` are mandatory.  ``` # docker
      run --rm -it \   -e VALIDATE_API_USER="validate_user" \   -e VALIDATE_API_PASSWORD="validate_password"
      \   -p 9001:9001 \   registry.gitlab.com/besmirzanaj/validate-email:webhook
      Emulate Docker CLI using podman. Create /etc/containers/nodocker to quiet msg.
      Show some variables for debug purposes VALIDATE_API_USER=validate_user VALIDATE_API_PASSWORD=validate_password
      BEARER_TOKEN=dmFsaWRhdGVfdXNlcjp2YWxpZGF0ZV9wYXNzd29yZAo= [webhook] 2024/12/07
      00:28:40 version 2.8.2 starting [webhook] 2024/12/07 00:28:40 setting up os
      signal watcher [webhook] 2024/12/07 00:28:40 attempting to load hooks from ./src/valid_email.yml
      [webhook] 2024/12/07 00:28:40 found 1 hook(s) in file [webhook] 2024/12/07 00:28:40   loaded:
      validate_email [webhook] 2024/12/07 00:28:40 serving hooks on http://0.0.0.0:9001/hooks/{id}
      [webhook] 2024/12/07 00:28:40 os signal watcher ready ```  Validate  ```bash
      VALIDATE_HOSTNAME="http://vps1.cloudalbania.com" # replace with the hostname
      you are running this, could be also 127.0.0.1 VALIDATE_URL="$VALIDATE_HOSTNAME:9001/hooks/validate_email"
      VALIDATE_API_USER="validate_user" # update with your user here VALIDATE_API_PASSWORD="validate_password"
      # update with your password here VALIDATE_AUTH_HEADER="Authorization: Bearer
      $(echo $VALIDATE_API_USER:$VALIDATE_API_PASSWORD | base64)"  curl -s --url "$VALIDATE_URL"
      \   -X POST -d ''{"email":"besmirtv@gmail.com"}'' \   -H "Content-type: Application/json"
      \   -H "$VALIDATE_AUTH_HEADER" | jq  {   "email": "besmirtv@gmail.com",   "status":
      "true" } ```   ## Running the program in Python  ### Build and run the app locally  ```console
      python3 -m venv .venv . .venv/bin/activate pip install -r requirements.txt python
      src/valid_email.py ```  ### TODO - est with no Auth validation  ``` $ curl -s
      http://127.0.0.1:9001/validate_email -X POST -d ''{"email":"besmirtv@gmail.com"}''
      -H ''Content-type: Application/json'' | jq {   "email": "besmirtv@gmail.com",   "status":
      "OK" } ```  or   ``` $ curl -s http://127.0.0.1:9001/validate_email -X POST
      -d @test.json -H ''Content-type: Application/json'' | jq {   "email": "besmirzanaj@gmail.com",   "status":
      "OK" } ```   ### Test with JWT Authentication  Either provide some environment
      values or create an `.env` file with the following structure:  ```bash $ cat
      .env VALIDATE_JWT_SECRET_KEY="RANDOM_JWT_SECRET_KEY" VALIDATE_API_USER="validate"
      VALIDATE_API_PASSWORD="aiheihoi3wua4lei4ooph7aideiSha7" ```  #### Accessing
      straight to IP/domain port 9001  Login to get the token. Demo username and password
      below. Please change the environment variables as above for a prod environment.  ```json
      {   "username": "validate",    "password": "aiheihoi3wua4lei4ooph7aideiSha7"
      } ```  Use the username and the password to get a new JWT token. Curl command:  ```bash
      VALIDATE_HOSTNAME="https://vps3.cloudalbania.com" # Update with your hostname.
      It can be also 127.0.0.1 VALIDATE_LOGIN_URL="$VALIDATE_HOSTNAME:9001/login"
      VALIDATE_TOKEN=$(curl -X POST "$VALIDATE_LOGIN_URL" -H "Content-Type: application/json"
      -d ''{"username": "validate", "password": "aiheihoi3wua4lei4ooph7aideiSha7"}''
      -s | jq .access_token -r)  echo $VALIDATE_TOKEN  eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.<long_base64>.7pWZ7bwRu5lk0ww-vs5IaeYx-HoD3a2VZm4_Gi8Y0x0
      ```  Then use the token with the API on the `/validate_email` endpoint:  ```bash
      VALIDATE_API_URL="$VALIDATE_HOSTNAME:9001/validate_email" curl -s "$VALIDATE_API_URL"
      -X POST -d ''{"email":"besmirtv@gmail.com"}'' -H ''Content-type: Application/json''
      -H "Authorization: Bearer $VALIDATE_TOKEN"   {   "email": "besmirtv@gmail.com",   "status":
      "true" } ```  #### Accessing with cloudflare proxy/tunnel  ```bash VALIDATE_HOSTNAME=verify.cloudalbania.com
      VALIDATE_LOGIN_URL="https://$VALIDATE_HOSTNAME/login" VALIDATE_TOKEN=$(curl
      -X POST "$VALIDATE_LOGIN_URL" -H "Content-Type: application/json" -d ''{"username":
      "validate", "password": "aiheihoi3wua4lei4ooph7aideiSha7"}'' -s | jq .access_token
      -r)  echo $VALIDATE_TOKEN  eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.<long_base64>.7pWZ7bwRu5lk0ww-vs5IaeYx-HoD3a2VZm4_Gi8Y0x0
      ```  Then use the token with the API  ```bash VALIDATE_API_URL="http://$VALIDATE_HOSTNAME/validate_email"
      curl -s "$VALIDATE_API_URL" -X POST -d ''{"email":"besmirtv@gmail.com"}'' -H
      ''Content-type: Application/json'' -H "Authorization: Bearer $VALIDATE_TOKEN"   {   "email":
      "besmirtv@gmail.com",   "status": "true" } ```  ## Helm  Install locally from
      the repo: helm install validate-email  validate-email/ --namespace validate-email
      --create-namespace  Uninstall helm uninstall validate-email --namespace validate-email  '
    digest: 8c26e9eafdc7037c6fd35cf8b8029b8d27de7502d31ffb490662887143ab1b98
    name: validate-email
    type: application
    urls:
    - https://github.com/besmirzanaj/charts/releases/download/validate-email-0.2.7/validate-email-0.2.7.tgz
    version: 0.2.7
  - apiVersion: v2
    appVersion: 0.2.0
    created: "2024-12-11T23:41:12.845540883Z"
    description: '# validate-email  Check email validity.  ## Introduction  This code
      will validate an email address if it is active. When you run it, make sure your
      host is allowed outbound access to port 25. Some VPS providers will ont allow
      that.  Can be run with [webook](https://github.com/adnanh/webhook) in BASH or
      with [Flask](https://flask.palletsprojects.com/en/stable/) in Python.   ## Running
      the program in BASH The Bash version will only allow bearer token authentication
      with a username/password combination.  **Locally in BASH**  This is not meant
      to be run from the console. Use the docker version below. If absolutely you
      need to run it, then, first update the `VALIDATE_API_USER` and `VALIDATE_API_PASSWORD`
      variables in the `.env` file or declare them as environment variables. Then
      run the app. An example below with declaring the env variables on the fly  ```bash
      $  VALIDATE_API_USER=validate_user VALIDATE_API_PASSWORD=validate_password ./src/bash_entrypoint.sh
      VALIDATE_API_PASSWORD=validate_password VALIDATE_API_USER=validate_user BEARER_TOKEN=dmFsaWRhdGVfdXNlcjp2YWxpZGF0ZV9wYXNzd29yZAo=
      [webhook] 2024/12/06 18:01:06 version 2.8.0 starting [webhook] 2024/12/06 18:01:06
      setting up os signal watcher [webhook] 2024/12/06 18:01:06 attempting to load
      hooks from ./src/valid_email.yml [webhook] 2024/12/06 18:01:06 os signal watcher
      ready [webhook] 2024/12/06 18:01:06 found 1 hook(s) in file [webhook] 2024/12/06
      18:01:06   loaded: validate_email [webhook] 2024/12/06 18:01:06 serving hooks
      on http://0.0.0.0:9001/hooks/{id} ```  Then issue the call with curl:  ```bash
      VALIDATE_HOSTNAME="http://vps3.cloudalbania.com" # replace with the hostname
      you are running this, could be also 127.0.0.1 VALIDATE_URL="$VALIDATE_HOSTNAME:9001/hooks/validate_email"
      VALIDATE_API_USER="validate_user" # update with your user here VALIDATE_API_PASSWORD="validate_password"
      # update with your password here VALIDATE_AUTH_HEADER="Authorization: Bearer
      $(echo $VALIDATE_API_USER:$VALIDATE_API_PASSWORD | base64)"  $ curl -s --url
      "$VALIDATE_URL" \   -X POST -d ''{"email":"besmirtv@gmail.com"}'' \   -H "Content-type:
      Application/json" \   -H "$VALIDATE_AUTH_HEADER" | jq  {   "email": "besmirtv@gmail.com",   "status":
      "true" } ```  **Bash in docker version**  Start it with the following. Remember
      that `VALIDATE_API_USER` and `VALIDATE_API_PASSWORD` are mandatory.  ``` # docker
      run --rm -it \   -e VALIDATE_API_USER="validate_user" \   -e VALIDATE_API_PASSWORD="validate_password"
      \   -p 9001:9001 \   registry.gitlab.com/besmirzanaj/validate-email:webhook
      Emulate Docker CLI using podman. Create /etc/containers/nodocker to quiet msg.
      Show some variables for debug purposes VALIDATE_API_USER=validate_user VALIDATE_API_PASSWORD=validate_password
      BEARER_TOKEN=dmFsaWRhdGVfdXNlcjp2YWxpZGF0ZV9wYXNzd29yZAo= [webhook] 2024/12/07
      00:28:40 version 2.8.2 starting [webhook] 2024/12/07 00:28:40 setting up os
      signal watcher [webhook] 2024/12/07 00:28:40 attempting to load hooks from ./src/valid_email.yml
      [webhook] 2024/12/07 00:28:40 found 1 hook(s) in file [webhook] 2024/12/07 00:28:40   loaded:
      validate_email [webhook] 2024/12/07 00:28:40 serving hooks on http://0.0.0.0:9001/hooks/{id}
      [webhook] 2024/12/07 00:28:40 os signal watcher ready ```  Validate  ```bash
      VALIDATE_HOSTNAME="http://vps1.cloudalbania.com" # replace with the hostname
      you are running this, could be also 127.0.0.1 VALIDATE_URL="$VALIDATE_HOSTNAME:9001/hooks/validate_email"
      VALIDATE_API_USER="validate_user" # update with your user here VALIDATE_API_PASSWORD="validate_password"
      # update with your password here VALIDATE_AUTH_HEADER="Authorization: Bearer
      $(echo $VALIDATE_API_USER:$VALIDATE_API_PASSWORD | base64)"  curl -s --url "$VALIDATE_URL"
      \   -X POST -d ''{"email":"besmirtv@gmail.com"}'' \   -H "Content-type: Application/json"
      \   -H "$VALIDATE_AUTH_HEADER" | jq  {   "email": "besmirtv@gmail.com",   "status":
      "true" } ```   ## Running the program in Python  ### Build and run the app locally  ```console
      python3 -m venv .venv . .venv/bin/activate pip install -r requirements.txt python
      src/valid_email.py ```  ### TODO - est with no Auth validation  ``` $ curl -s
      http://127.0.0.1:9001/validate_email -X POST -d ''{"email":"besmirtv@gmail.com"}''
      -H ''Content-type: Application/json'' | jq {   "email": "besmirtv@gmail.com",   "status":
      "OK" } ```  or   ``` $ curl -s http://127.0.0.1:9001/validate_email -X POST
      -d @test.json -H ''Content-type: Application/json'' | jq {   "email": "besmirzanaj@gmail.com",   "status":
      "OK" } ```   ### Test with JWT Authentication  Either provide some environment
      values or create an `.env` file with the following structure:  ```bash $ cat
      .env VALIDATE_JWT_SECRET_KEY="RANDOM_JWT_SECRET_KEY" VALIDATE_API_USER="validate"
      VALIDATE_API_PASSWORD="aiheihoi3wua4lei4ooph7aideiSha7" ```  #### Accessing
      straight to IP/domain port 9001  Login to get the token. Demo username and password
      below. Please change the environment variables as above for a prod environment.  ```json
      {   "username": "validate",    "password": "aiheihoi3wua4lei4ooph7aideiSha7"
      } ```  Use the username and the password to get a new JWT token. Curl command:  ```bash
      VALIDATE_HOSTNAME="https://vps3.cloudalbania.com" # Update with your hostname.
      It can be also 127.0.0.1 VALIDATE_LOGIN_URL="$VALIDATE_HOSTNAME:9001/login"
      VALIDATE_TOKEN=$(curl -X POST "$VALIDATE_LOGIN_URL" -H "Content-Type: application/json"
      -d ''{"username": "validate", "password": "aiheihoi3wua4lei4ooph7aideiSha7"}''
      -s | jq .access_token -r)  echo $VALIDATE_TOKEN  eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.<long_base64>.7pWZ7bwRu5lk0ww-vs5IaeYx-HoD3a2VZm4_Gi8Y0x0
      ```  Then use the token with the API on the `/validate_email` endpoint:  ```bash
      VALIDATE_API_URL="$VALIDATE_HOSTNAME:9001/validate_email" curl -s "$VALIDATE_API_URL"
      -X POST -d ''{"email":"besmirtv@gmail.com"}'' -H ''Content-type: Application/json''
      -H "Authorization: Bearer $VALIDATE_TOKEN"   {   "email": "besmirtv@gmail.com",   "status":
      "true" } ```  #### Accessing with cloudflare proxy/tunnel  ```bash VALIDATE_HOSTNAME=verify.cloudalbania.com
      VALIDATE_LOGIN_URL="https://$VALIDATE_HOSTNAME/login" VALIDATE_TOKEN=$(curl
      -X POST "$VALIDATE_LOGIN_URL" -H "Content-Type: application/json" -d ''{"username":
      "validate", "password": "aiheihoi3wua4lei4ooph7aideiSha7"}'' -s | jq .access_token
      -r)  echo $VALIDATE_TOKEN  eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.<long_base64>.7pWZ7bwRu5lk0ww-vs5IaeYx-HoD3a2VZm4_Gi8Y0x0
      ```  Then use the token with the API  ```bash VALIDATE_API_URL="http://$VALIDATE_HOSTNAME/validate_email"
      curl -s "$VALIDATE_API_URL" -X POST -d ''{"email":"besmirtv@gmail.com"}'' -H
      ''Content-type: Application/json'' -H "Authorization: Bearer $VALIDATE_TOKEN"   {   "email":
      "besmirtv@gmail.com",   "status": "true" } ```  ## Helm  Install locally from
      the repo: helm install validate-email  validate-email/ --namespace validate-email
      --create-namespace  Uninstall helm uninstall validate-email --namespace validate-email  '
    digest: 81100896930fbfc784838f88068269ad6178ae61b74e41599f6c71ab1085537d
    name: validate-email
    type: application
    urls:
    - https://github.com/besmirzanaj/charts/releases/download/validate-email-0.2.5/validate-email-0.2.5.tgz
    version: 0.2.5
  - apiVersion: v2
    appVersion: 0.2.0
    created: "2024-12-10T05:21:08.224466907Z"
    description: A Helm chart for running the validate email app in Kubernetes
    digest: ab25ac2aff76b253778dbf58df1bca73e1055a950d595a2e3b072eb4623f9df2
    name: validate-email
    type: application
    urls:
    - https://github.com/besmirzanaj/charts/releases/download/validate-email-0.2.4/validate-email-0.2.4.tgz
    version: 0.2.4
  - apiVersion: v2
    appVersion: 0.2.0
    created: "2024-12-10T04:38:26.763054701Z"
    description: A Helm chart for running the validate email app in Kubernetes
    digest: 076c6bdc2652b41b1533eee8e5088a49c71623a9214ab06548972d5aa08c78d4
    name: validate-email
    type: application
    urls:
    - https://github.com/besmirzanaj/charts/releases/download/validate-email-v0.2.3/validate-email-v0.2.3.tgz
    version: v0.2.3
generated: "2024-12-30T17:59:06.060713885Z"
